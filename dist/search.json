[
  {
    "objectID": "posts/gravel/index.html",
    "href": "posts/gravel/index.html",
    "title": "Driveway Surfacing",
    "section": "",
    "text": "Estimating materials needed for a simple gravel road, like my driveway.\nBesides the compacted native substrate, a gravel road typically has three components: a layer of geotextile to prevent mixing the base with the substrate, a base layer of about 2” crushed rock to provide a foundation, and a surface layer of material that develops a hard surface. Each of the layers is 4 to 8” or so. A driveway will typically be about 12’ wide, 12 inches thick, and the surface must be sloped to prevent water pooling.\nGravel is generally ordered by weight (since the yards use scales rather than buckets). A ton of crushed rock / gravel is typically about \\(1.4 ton.yd^{-3}\\). A dump truck generally holds 22 ton, which equates to 15.7 yd. Crusher run includes the fines, and this is usally a bit heavier and variable by moisture content (best to order after a dry spell).\nA one inch layer on a 12’ wide roadway is one cubic foot per foot of roadway. Since one cubic yard is \\(27 ft^3\\), one cubic yard will cover 27 ft, and one truck will cover about 424 ft at a one inch depth, 106ft at 4”, and 71ft at 6”.\nThe formula for tons per ft length per inch thckness is:\n\\[\n\\begin{eqnarray}\nt &=& length \\times 12 \\times \\frac{thick}{12 \\times 27} \\times 1.4 \\\\\n&=& length \\times thick \\times 0.05185 \\\\\n&=& \\frac{length \\times thick}{19.28}\n\\end{eqnarray}\n\\]\nAssuming $36 / ton, the cost per foot is: \\[\n\\begin{eqnarray}\ncost &=& \\frac{length \\times thick}{19.28} \\times 36 \\\\\n&=& length \\times thick \\times 1.867\n\\end{eqnarray}\n\\]\nThis comes out to around $1500 per one hundred feet of driveway at 8” thick, plus machine time and geotextile."
  },
  {
    "objectID": "posts/cesium/million_points.html",
    "href": "posts/cesium/million_points.html",
    "title": "Show a million points on Cesium",
    "section": "",
    "text": "This page shows a cesium view with 1,000,000 randomly generated points displayed. Mousing over a point will show a tag with the point ID. The point size is adjusted by a NearFarScalar responsive to the camera distance from the points.\nAlthough terrain is shown, the points are not adjusted with terrain height. There is an option to compute the height of points using sampleTerrainMostDetailed, however that should only be used when the results can be preserved since it is fairly slow (generally a couple seconds per batch of 1000).\n\n\n\n\n\n\n\n\nCesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';\n\n\n\n\n\n\n\nfunction randomCoordinateJitter(degree, margin) {\n    return degree + margin * (Math.random() - 0.5) / 0.5;\n}\n\nasync function sleep(ms=500) {\n        return new PromiseRejectionEvent(resolve =&gt; setTimeout(resolve, ms));\n}\n\nfunction createShowPrimitive(viewer) {\n    return function(movement) {\n        // Get the point at the mouse end position\n        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);        \n\n        // Clear the current selection, if there is one and it is different to the selectPoint\n        if (viewer.currentSelection !== null) {\n            //console.log(`selected.p ${viewer.currentSelection}`)\n            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {\n                console.log(`selected.p 2 ${viewer.currentSelection}`)\n                viewer.currentSelection.primitive.pixelSize = 4;\n                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;\n                viewer.currentSelection.outlineWidth = 0;\n                viewer.currentSelection = null;\n            }\n        }\n\n        // If selectPoint is valid and no currently selected point\n        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n            //console.log(`showPrimitiveId ${selectPoint.id}`);\n            const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)\n            viewer.pointLabel.position = selectPoint.primitive.position;\n            viewer.pointLabel.label.show = true;\n            viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;\n            selectPoint.primitive.pixelSize = 20;\n            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;\n            selectPoint.primitive.outlineWidth = 3;\n            viewer.currentSelection = selectPoint;\n        } else {\n            viewer.pointLabel.label.show = false;\n        }            \n    }\n}\n\n\nclass CView {\n    constructor(target) {\n        this.viewer = new Cesium.Viewer(\n            target, {\n                timeline: false,\n                animation: false,\n                baseLayerPicker: false,\n                fullscreenElement: target,\n                terrain: Cesium.Terrain.fromWorldTerrain()\n            });\n        this.currentSelection = null;\n        this.point_size = 1;\n        this.n_points = 0;\n        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html\n        this.points = new Cesium.PointPrimitiveCollection();\n        this.viewer.scene.primitives.add(this.points);\n     \n        //this.viewer.scene.globe.depthTestAgainstTerrain = false;\n        //this.viewer.scene.logarithmicDepthBuffer = false;\n\n        this.pointLabel = this.viewer.entities.add({\n            label: {\n            show: false,\n            showBackground: true,\n            font: \"14px monospace\",\n            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,\n            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,\n            pixelOffset: new Cesium.Cartesian2(15, 0),\n            // this attribute will prevent this entity clipped by the terrain\n            disableDepthTestDistance: Number.POSITIVE_INFINITY,\n            text:\"\",\n            },\n        });\n\n        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        // Can also do this rather than wait for the points to be generated\n        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n\n    enableTracking() {\n        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n\n    /**\n     * Wait for the terrain provider to be available. This is created asynchronously during the\n     * view initialization which often returns before the terrain provider is complete. Here we \n     * wait around for up to 3 seconds (10x300ms) until the terrain provider is ready.\n     */\n    async waitForTerrainProvider() {\n        let n = 0;\n        while (n &lt; 10 && !Cesium.defined(this.viewer.terrainProvider)) {\n            await sleep(300);\n            n += 1;\n        }\n    }\n\n    /**\n     * Add points at terrain elevation.\n     * \n     * This uses sampleTerrainMostDetailed to compute the terrain elevations for batches\n     * of 100 points at a time. It typically takes a couple seconds for a batch of 1000 to complete\n     * so using 100 provides a more interesting visual as the points are added.\n     * \n     * The actual time seems to be dependent on exogenous factors.\n     */\n    async generatePointsAtTerrain(n_points=1000, point_size=4) {\n        this.n_points = n_points;\n        this.point_size = point_size;\n        // change point size with camera distance\n        const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);\n        let total = 0;\n        await this.waitForTerrainProvider();\n        let batch_size = 1000;\n        while (total &lt; this.n_points) {\n            const batch = [];\n            if (n_points - total &lt; batch_size) {\n                batch_size = n_points - total;\n            }\n            // create a batch of coordinates\n            for (let i=0; i&lt;batch_size; i++) {\n                batch.push(Cesium.Cartographic.fromDegrees(\n                    randomCoordinateJitter(0.0, 180.0),  //longitude\n                    randomCoordinateJitter(0.0, 90.0),   //latitude\n                ));\n            }\n            // compute the terrain (ellipsoid) elevations for the coordinates\n            // since this is async, it has the convenient result of letting the display update \n            // as more points are added.\n            const updatedPositions = await Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, batch, true);\n\n            // create points from the updated coordinates that have the terrain elevation added.\n            for (let i=0; i&lt;batch.length; i++) {\n                let color = Cesium.Color.PINK;\n                if ((i % 2) === 0) {\n                    color = Cesium.Color.CYAN;\n                }\n                let pt = updatedPositions[i];\n                this.points.add({\n                    id: total,\n                    position: Cesium.Cartesian3.fromRadians(pt.longitude, pt.latitude, pt.height),\n                    pixelSize: this.point_size,\n                    color: color,\n                    scaleByDistance: scalar,\n                });\n                total += 1;\n            }\n        }\n    }\n\n    async generatePoints(n_points=1000, point_size=4) {\n        this.n_points = n_points;\n        this.point_size = point_size;\n        // https://cesium.com/learn/ion-sdk/ref-doc/NearFarScalar.html\n        const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);\n        for (var i = 0; i &lt; this.n_points; i++) {\n            let color = Cesium.Color.PINK;\n            if ((i % 2) === 0) {\n                color = Cesium.Color.CYAN;\n            }\n            this.points.add({\n                id: i,\n                // https://cesium.com/learn/cesiumjs/ref-doc/Cartesian3.html#.fromDegrees\n                position: Cesium.Cartesian3.fromDegrees(\n                    randomCoordinateJitter(0.0, 180.0),  //longitude\n                    randomCoordinateJitter(0.0, 90.0),   //latitude\n                    0,//randomCoordinateJitter(10.0, 10.0), //elevation, m\n                ),\n                pixelSize: this.point_size,\n                color: color,\n                scaleByDistance: scalar,\n                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,\n            });\n        }\n    }\n\n    async doCreatePoints() {\n        const t0 = new Date().getTime();\n        console.log(`start generating`);\n        // Generating points is fast, but computing their elevation is fairly slow at a couple seconds per batch of 1000.\n        //await this.generatePointsAtTerrain(10000);\n        await this.generatePoints(1000000);\n        const t1 = new Date().getTime();\n        console.log(`done generating. Took ${(t1-t0)/1000} seconds`);\n    }\n}\n\n\ncontent = new CView(\"cesiumContainer\");\nsetTimeout(function() {\n    content.doCreatePoints().then(content.enableTracking());\n}, 1000);"
  },
  {
    "objectID": "posts/catching_rain/index.html",
    "href": "posts/catching_rain/index.html",
    "title": "Catching Rain",
    "section": "",
    "text": "Collecting rainwater and storing it in a cistern for household use is not a novel concept. How much roof area and storage is needed? How should it be treated prior to consumption?\nRainwater was considered to be a generally clean source of water requiring minimal treatment for safe consumption (Thomas et al. 2014). A recent study (Cousins et al. 2022) reveals that PFAS contamination is now global, and untreated rainwater is no longer safe to drink anywhere on the earth. It is thus necessary to filter rainwater with a recommended process (US EPA 2018) for consumption. But what about the impacts of PFAS on the natural environment, with no luxury of filtration before consumption?\nThe average annual precipitation in Anne Arundel county is 42.45 inches, with an average of 4.17±0.25 per month with a 95% CI 1. Note that there is a lot of variability. May of 2015 was about 1.5 inches, June 2015 was over 12.5 inches of rain.\n1 NOAA NCDC, Anne Arundel County\n\nCode\nimport os\nimport json\nimport itables\nimport pandas as pd\nimport plotly.io as pio\nimport plotly.express as px\n\npio.renderers.default = \"notebook\"\n\ndata = []\ndpath = \"data/\"\nfor m in range(1,13):\n    with open(os.path.join(dpath, f\"precip_{m}.json\"), \"r\") as inf:\n        mdata = json.load(inf)\n        for k in mdata[\"data\"].keys():\n            year = int(k[:4])\n            if year &lt; 2021:\n                month = m\n                v = float(mdata[\"data\"][k][\"value\"])\n                row = [year, month, v]\n                data.append(row)\ndf = pd.DataFrame(data, columns=[\"Year\", \"Month\", \"Precip\"])\naaco_precip = px.scatter(\n    df.query(\"Year &lt; 2021\").groupby([\"Year\"]).sum().reset_index(), \n    x=\"Year\", \n    y=\"Precip\",\n    trendline=\"ols\",\n    labels={\n        \"Year\":\"Year\",\n        \"Precip\":\"Precip. (in)\"\n    },\n    height=400\n)\naaco_precip.show()\nstats = px.get_trendline_results(aaco_precip)\nmonthly_means = df.query(\"Year &lt; 2021\").groupby(\"Month\").mean().reset_index()\nojs_define(monthly_means=monthly_means.values.tolist())\nmonthly_std = df.query(\"Year &lt; 2021\").groupby(\"Month\").std().reset_index()\nmonthly_precip = px.bar(\n    monthly_means,\n    x = \"Month\",\n    y = \"Precip\",\n    labels={\n        \"Month\":\"Month\",\n        \"Precip\":\"Precip. (in)\"\n    },\n    height=300,\n    error_y=monthly_std[\"Precip\"],\n)\nmonthly_precip.update_traces(marker_color='rgb(158,202,225)', marker_line_color='rgb(8,48,107)',\n                  marker_line_width=1.5, opacity=0.6)\nmonthly_precip.show()\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\n\n\n                            \n                                            \n\n\nThe calculations are straight forward:\nOne inch is \\(\\frac{1}{12} ft\\), so one inch of rain on one square foot of surface is:\n\\[\n\\frac{1}{12}ft \\times 1ft \\times 1ft = 0.08333ft^3\n\\]\nGiven \\(1 gal = 231in^3\\) and \\(1ft^3 = 1728in^3\\), so \\(1ft^3 = 7.48049\\:gal\\) 2:\n2 NIST Handbook 133. Appendix E. General Tables of Units of Measurement\\[\n1in = 0.08333 \\times 7.48049 = 0.62337\\:gal\n\\]\nSo one inch of rain on one square foot of surface yields 0.62337 gallons.\nA household will use about 125 gallons per day with no deliberate conservation3. That equates to about 45,625 gallons per year. Assuming an average of 42.5” rain for the year in this part of Maryland, a catchment area of about 1800 sqft will be sufficient, more or less. Variability in input (rainfall) and output (use) is quite high, so storage buffering is necessary to get through the high use, low rainfall periods.\n3 The range is is large, up to about 650 g/day, with median of about 125.\nCode\nfrom IPython.display import Markdown\n\ndef gallons(area_feet, amount_inches):\n    return amount_inches * area_feet * 0.62337\n\nareas = [1,10,100,200,400,800,1200,1800]\nrainfall = [0.25, 1,2,4.2,8,10,42.5]\n\ntable = []\ntable.append('&lt;table class=\"table table-sm table-striped\"&gt;')\ntable.append('&lt;thead&gt;')\ntable.append(f'&lt;tr&gt;&lt;th style=\"border-bottom: none;\"&gt;&lt;/th&gt;&lt;th colspan=\"{len(rainfall)}\" style=\"text-align:center;\"&gt;Rainfall&lt;/th&gt;&lt;/tr&gt;')\nh = [f'&lt;th style=\"text-align:right;\"&gt;{v}&quot;&lt;/th&gt;' for v in rainfall]\ntable.append(f'&lt;tr&gt;&lt;th&gt;Area ft&lt;sup&gt;2&lt;/sup&gt;{\"\".join(h)}&lt;/tr&gt;')\ntable.append('&lt;/thead&gt;')\ntable.append('&lt;tbody&gt;')\ndata = []\nheader = [\"Area $ft^2$\",] + [f'{v}\"' for v in rainfall]\nfor area in areas:\n    row = [f'&lt;td style=\"text-align:right;\"&gt;{area}&lt;/td&gt;',]\n    for amount in rainfall:\n        row.append(f'&lt;td style=\"text-align:right;\"&gt;{gallons(area, amount):5.1f}&lt;/td&gt;')\n    table.append(f\"&lt;tr&gt;{''.join(row)}&lt;/tr&gt;\")\n\ntable.append('&lt;/tbody&gt;')\ntable.append('&lt;/table&gt;')\nMarkdown(\"\\n\".join(table))\n\n\n\n\n\n\n\nRainfall\n\n\n\n\nArea ft2\n\n0.25\"\n\n\n1\"\n\n\n2\"\n\n\n4.2\"\n\n\n8\"\n\n\n10\"\n\n\n42.5\"\n\n\n\n\n\n\n1\n\n\n0.2\n\n\n0.6\n\n\n1.2\n\n\n2.6\n\n\n5.0\n\n\n6.2\n\n\n26.5\n\n\n\n\n10\n\n\n1.6\n\n\n6.2\n\n\n12.5\n\n\n26.2\n\n\n49.9\n\n\n62.3\n\n\n264.9\n\n\n\n\n100\n\n\n15.6\n\n\n62.3\n\n\n124.7\n\n\n261.8\n\n\n498.7\n\n\n623.4\n\n\n2649.3\n\n\n\n\n200\n\n\n31.2\n\n\n124.7\n\n\n249.3\n\n\n523.6\n\n\n997.4\n\n\n1246.7\n\n\n5298.6\n\n\n\n\n400\n\n\n62.3\n\n\n249.3\n\n\n498.7\n\n\n1047.3\n\n\n1994.8\n\n\n2493.5\n\n\n10597.3\n\n\n\n\n800\n\n\n124.7\n\n\n498.7\n\n\n997.4\n\n\n2094.5\n\n\n3989.6\n\n\n4987.0\n\n\n21194.6\n\n\n\n\n1200\n\n\n187.0\n\n\n748.0\n\n\n1496.1\n\n\n3141.8\n\n\n5984.4\n\n\n7480.4\n\n\n31791.9\n\n\n\n\n1800\n\n\n280.5\n\n\n1122.1\n\n\n2244.1\n\n\n4712.7\n\n\n8976.5\n\n\n11220.7\n\n\n47687.8\n\n\n\n\nNotes:\n\nRainwater characteristics Keresztesi et al. 2020\nRainwater in West Kalimantan Khayan et al. 2019\nRainwater treatment Kim et al. 2016\nRainwater harvesting regulations, “Rainwater Harvesting Regulations Map” n.d.\nRainwater harveting in American Samoa, Kirs et al. 2017\n\n\n\n\n\n\nReferences\n\nCousins, Ian T., Jana H. Johansson, Matthew E. Salter, Bo Sha, and Martin Scheringer. 2022. “Outside the Safe Operating Space of a New Planetary Boundary for Per- and Polyfluoroalkyl Substances (PFAS).” Environmental Science & Technology 56 (16): 11172–79. https://doi.org/10.1021/acs.est.2c02765.\n\n\nKeresztesi, Ágnes, Ion-Andrei Nita, Réka Boga, Marius-Victor Birsan, Zsolt Bodor, and Róbert Szép. 2020. “Spatial and Long-Term Analysis of Rainwater Chemistry over the Conterminous United States.” Environmental Research 188 (September): 109872. https://doi.org/10.1016/j.envres.2020.109872.\n\n\nKhayan, Khayan, Adi Heru Husodo, Indwiani Astuti, Sudarmadji Sudarmadji, and Tjut Sugandawaty Djohan. 2019. “Rainwater as a Source of Drinking Water: Health Impacts and Rainwater Treatment.” Journal of Environmental and Public Health 2019 (July): e1760950. https://doi.org/10.1155/2019/1760950.\n\n\nKim, Taegyu, Dennis Lye, Maura Donohue, Jatin Mistry, Stacy Pfaller, Stephen Vesper, and Mary Kirisits. 2016. “Harvested Rainwater Quality Before and After Treatment and Distribution in Residential Systems (In Press).” Journal - American Water Works Association 108 (November). https://doi.org/10.5942/jawwa.2016.108.0182.\n\n\nKirs, Marek, Philip Moravcik, Pradip Gyawali, Kerry Hamilton, Veljo Kisand, Ian Gurr, Christopher Shuler, and Warish Ahmed. 2017. “Rainwater Harvesting in American Samoa: Current Practices and Indicative Health Risks.” Environmental Science and Pollution Research International 24 (May). https://doi.org/10.1007/s11356-017-8858-z.\n\n\n“Rainwater Harvesting Regulations Map.” n.d. Energy.gov. Accessed May 1, 2022. https://www.energy.gov/eere/femp/rainwater-harvesting-regulations-map.\n\n\nThomas, Russell B., Mary Jo Kirisits, Dennis J. Lye, and Kerry A. Kinney. 2014. “Rainwater Harvesting in the United States: A Survey of Common System Practices.” Journal of Cleaner Production 75 (July): 166–73. https://doi.org/10.1016/j.jclepro.2014.03.073.\n\n\nUS EPA, ORD. 2018. “Reducing PFAS in Drinking Water with Treatment Technologies.” Overviews and {{Factsheets}}. https://www.epa.gov/sciencematters/reducing-pfas-drinking-water-treatment-technologies."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "Exploring IMLGS\n\n\n\n\n\n\n\n\n\n\nShow a million points on Cesium\n\n\n\nrecipe\n\n\nspatial\n\n\ncesium\n\n\n\n\n\n\n\n\n\n\n\nExploring SI Occurrences\n\n\n\n\n\n\n\n\n\n\nCatching Rain\n\n\n\nliving\n\n\nrainwater\n\n\n\n\n2022-11-01\n\n\n\n\n\n\n\n\n\n\n\nDriveway Surfacing\n\n\n\nliving\n\n\ninfrastructure\n\n\n\n\n2022-04-02\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/cesium/si_snapshot.html",
    "href": "posts/cesium/si_snapshot.html",
    "title": "Exploring SI Occurrences",
    "section": "",
    "text": "This page renders content from a static snapshot of Smithinsonian Institution occurrence records retrieved from GBIF on 2025-04-22. The data was converted to parquet and of the approximately 10 million records, there are about 480,000 distinct locations which are shown on the map. Each point represents between 1 and several thousand occurrence records. Clicking on a point will show an excerpt of the records in a table below the map.\n\n\n\n\n\nduckdb = import(\"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm/+esm\");\n\nasync function instantiate(duckdb) {\n\n  const CDN_BUNDLES = duckdb.getJsDelivrBundles(),\n  bundle = await duckdb.selectBundle(CDN_BUNDLES), // Select a bundle based on browser checks\n  worker_url = URL.createObjectURL(\n    new Blob([ `importScripts(\"${bundle.mainWorker}\");` ], {\n      type: \"text/javascript\"\n    })\n  );\n\n  // Instantiate the async version of DuckDB-WASM\n  const worker = new Worker(worker_url),\n  logger = new duckdb.ConsoleLogger(\"DEBUG\"),\n  db = new duckdb.AsyncDuckDB(logger, worker);\n\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n\n  return db;\n}\n\nDuckDB = await instantiate(duckdb);\ndb = {\n    const db = await DuckDB.connect();\n    const parquet_path = \"https://s3.beehivebeach.com/smithsonian/occurrence.parquet\";\n    let q = `install h3 from community;`\n    await db.query(q);\n    q = 'load h3;';\n    await db.query(q);\n    q = `create view occurrence as select * from read_parquet('${parquet_path}')`;\n    await db.query(q);\n    return db;q\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmutable data_loaded = \"Loading...\";\n\nmutable num_points = 0;\n\ncolors = {\n    const c = [\n        Cesium.Color.CYAN,\n        Cesium.Color.GOLDENROD,\n        Cesium.Color.GOLD,\n        Cesium.Color.HOTPINK,\n        Cesium.Color.RED,\n    ]\n    return c;\n}\n\nnum_records = {\n    const results = await db.query(\"select count(*) as n from occurrence\");\n    for (const row of results) {\n        return row.n;\n    }\n}\n\npointdata = {\n    //const colors = await makeColors();\n    const query = `SELECT h3, h3_cell_to_lat(h3) as latitude, h3_cell_to_lng(h3) as longitude, cast(count(*) as integer) as n from occurrence where h3 is not null group by h3`;\n    const recorddata = await db.query(query);\n    const scalar = new Cesium.NearFarScalar(1.5e2, 3, 8.0e6, 0.2);\n    const color = Cesium.Color.PINK;\n    const point_size = 4;\n    let nrecs = 0;\n    for (const row of recorddata) {\n        const pp = content.points.add({\n            id: `${row.h3}|${row.n}`,\n            // https://cesium.com/learn/cesiumjs/ref-doc/Cartesian3.html#.fromDegrees\n            position: Cesium.Cartesian3.fromDegrees(\n                row.longitude,  //longitude\n                row.latitude,   //latitude\n                0,//randomCoordinateJitter(10.0, 10.0), //elevation, m\n            ),\n            pixelSize: point_size,\n            color: colors[Math.round(Math.log10(row.n))],\n            //color: Cesium.Color.PINK,\n            scaleByDistance: scalar,\n        });\n        nrecs += 1;\n        if (nrecs % 10000 === 0) {\n            mutable data_loaded = `Loaded ${nrecs} locations.`;                \n        }\n    }\n    mutable num_points = nrecs;\n    mutable data_loaded = `Loaded ${nrecs} locations.`;\n    content.enableTracking();\n    return recorddata;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';\n\n\n\n\n\n\n\nclass Overlay {\n    constructor(target, width=\"140px\") {\n        this.data = {}\n        this.ele = document.createElement(\"div\")\n        this.ele.setAttribute(\"class\", \"cesium-topleft\");\n        this.ele.style.width = width;\n        const target_ele = document.getElementById(target);\n        const container  = target_ele.querySelector(\".cesium-widget\");\n        container.insertBefore(this.ele, container.firstChild);\n    }\n\n    render() {\n        const rows=[];\n        if (this.data.longitude === \"\"){\n            rows.push(`&lt;tr&gt;&lt;td&gt;XY&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;`);\n        } else {\n            rows.push(`&lt;tr&gt;&lt;td&gt;XY&lt;/td&gt;&lt;td&gt;${this.data.longitude}, ${this.data.latitude}&lt;/td&gt;&lt;/tr&gt;`);\n        }\n        for (const [k,v] of Object.entries(this.data)){\n            if ((k === \"latitude\") || (k === \"longitude\")) {\n                continue;\n            }\n            rows.push(`&lt;tr&gt;&lt;td&gt;${k}&lt;/td&gt;&lt;td&gt;${((v === null) ? \"\" : v)}&lt;/td&gt;&lt;/tr&gt;`);\n        }\n        this.ele.innerHTML = `&lt;table&gt;${rows.join(\"\\n\")}&lt;/table&gt;`;\n    }\n\n    update(data, do_render=true) {\n        for (const [key,value] of Object.entries(data)) {\n            this.data[key] = value;\n        }\n        if (do_render) {\n            this.render();\n        }\n    }\n}\n\n\nfunction createShowPrimitive(viewer) {\n    return async function(movement) {\n        // Get the point at the mouse end position\n        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);        \n\n        // Clear the current selection, if there is one and it is different to the selectPoint\n        if (viewer.currentSelection !== null) {\n            //console.log(`selected.p ${viewer.currentSelection}`)\n            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {\n                //console.log(`selected.p 2 ${viewer.currentSelection}`)\n                viewer.currentSelection.primitive.pixelSize = 4;\n                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;\n                viewer.currentSelection.outlineWidth = 0;\n                viewer.currentSelection = null;\n            }\n        }\n\n        // If selectPoint is valid and no currently selected point\n        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n            //console.log(`showPrimitiveId ${selectPoint.id}`);\n            const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)\n            viewer.pointLabel.position = selectPoint.primitive.position;\n            viewer.pointLabel.label.show = true;\n            //viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;\n            const label = `n:${selectPoint.id.split(\"|\")[1]}`;\n            viewer.pointLabel.label.text = `${label}`;\n            selectPoint.primitive.pixelSize = 20;\n            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;\n            selectPoint.primitive.outlineWidth = 3;\n            viewer.currentSelection = selectPoint;\n            //don't do this:\n            //getRecord(selectPoint.id).then((data) =&gt; {\n            //    viewer.overlay.update(data);\n            //})\n            //or this:\n            //viewer.overlay.update(await getRecord(selectPoint.id));\n            // They are too slow. Either create a timeout for de-bouncing or use a click event.\n        } else {\n            viewer.pointLabel.label.show = false;\n        }\n        \n        // Mouse coordinates\n        const ray = viewer.viewer.camera.getPickRay(movement.endPosition);\n        const mousePosition = viewer.viewer.scene.globe.pick(ray, viewer.viewer.scene);\n        if (Cesium.defined(mousePosition)) {\n            const cartographic = Cesium.Cartographic.fromCartesian(mousePosition);\n            viewer.overlay.update({\n                longitude: Cesium.Math.toDegrees(cartographic.longitude).toFixed(3),\n                latitude: Cesium.Math.toDegrees(cartographic.latitude).toFixed(3)\n            })\n        } else {\n            viewer.overlay.update({latitude:\"\", longitude:\"\"});\n        }\n    }\n}\n\nclass CView {\n    constructor(target) {\n        this.viewer = new Cesium.Viewer(\n            target, {\n                timeline: false,\n                animation: false,\n                baseLayerPicker: false,\n                fullscreenElement: target,\n                terrain: Cesium.Terrain.fromWorldTerrain()\n            });\n        this.overlay = new Overlay(target); \n        this.currentSelection = null;\n        this.point_size = 1;\n        this.n_points = 0;\n        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html\n        this.points = new Cesium.PointPrimitiveCollection();\n        this.viewer.scene.primitives.add(this.points);\n     \n        this.pointLabel = this.viewer.entities.add({\n            label: {\n            show: false,\n            showBackground: true,\n            font: \"14px monospace\",\n            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,\n            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,\n            pixelOffset: new Cesium.Cartesian2(15, 0),\n            // this attribute will prevent this entity clipped by the terrain\n            disableDepthTestDistance: Number.POSITIVE_INFINITY,\n            text:\"\",\n            },\n        });\n\n        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        // Can also do this rather than wait for the points to be generated\n        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n\n        this.selectHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        this.selectHandler.setInputAction(async (e) =&gt; {\n            const selectPoint = this.viewer.scene.pick(e.position);\n            if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n                //this.overlay.update(await getRecord(selectPoint.id));\n                console.log(`Selected h3=${selectPoint.id}`);\n                getRecords(selectPoint.id);\n            } else {\n                //this.overlay.update(await getRecord(null));\n                getRecords(null);\n            }\n        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);        \n        \n    }\n\n    enableTracking() {\n        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n}\n\n\nasync function getRecords(idx) {\n    if (idx === null) {\n        mutable selected_h3 = [];\n    }\n    console.log(`Looking for record ${idx}...`);\n    const h3 = idx.split(\"|\")[0];\n    const q = `select occurrenceID, institutionCode, collectionCode, catalogNumber,  family, genus, species, eventDate from occurrence where h3=${h3}`;\n    const result = db.query(q);\n    mutable selected_h3 = await result;\n    console.log(\"Donel\")\n}\n\ncontent = new CView(\"cesiumContainer\");\n\nmutable selected_h3 = [];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSelected  records.\n\nviewof selectedRecords = Inputs.table(selected_h3, {\n    format: {\n        occurrenceID: d =&gt; htl.html`&lt;a href='${d}' target='_blank'&gt;${d}&lt;/a&gt;`\n    }\n});"
  }
]